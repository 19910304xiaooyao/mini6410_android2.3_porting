
s3c_fimc_core.o:     file format elf32-littlearm


Disassembly of section .text:

00000000 <s3c_fimc_poll>:

	return 0;
}

static u32 s3c_fimc_poll(struct file *filp, poll_table *wait)
{
   0:	e92d4010 	push	{r4, lr}
	unsigned long key;
} poll_table;

static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)
{
	if (p && wait_address)
   4:	e1a02001 	mov	r2, r1
	struct s3c_fimc_control *ctrl = filp->private_data;
   8:	e5904068 	ldr	r4, [r0, #104]	; 0x68
   c:	e3520000 	cmp	r2, #0
  10:	13740030 	cmnne	r4, #48	; 0x30
  14:	e2841030 	add	r1, r4, #48	; 0x30
  18:	0a000001 	beq	24 <s3c_fimc_poll+0x24>
		p->qproc(filp, wait_address, p);
  1c:	e5923000 	ldr	r3, [r2]
  20:	e12fff33 	blx	r3
	u32 mask = 0;

	poll_wait(filp, &ctrl->waitq, wait);

	if (IS_IRQ_HANDLING(ctrl))
  24:	e5940014 	ldr	r0, [r4, #20]
		mask = POLLIN | POLLRDNORM;

	FSET_STOP(ctrl);
  28:	e3c0300f 	bic	r3, r0, #15
  2c:	e3833002 	orr	r3, r3, #2

	return mask;
}
  30:	e2100004 	ands	r0, r0, #4
	poll_wait(filp, &ctrl->waitq, wait);

	if (IS_IRQ_HANDLING(ctrl))
		mask = POLLIN | POLLRDNORM;

	FSET_STOP(ctrl);
  34:	e5843014 	str	r3, [r4, #20]

	return mask;
}
  38:	13a00041 	movne	r0, #65	; 0x41
  3c:	e8bd8010 	pop	{r4, pc}

00000040 <s3c_fimc_write>:

static
ssize_t s3c_fimc_write(struct file *filp, const char *b, size_t c, loff_t *offset)
{
	return 0;
}
  40:	e3a00000 	mov	r0, #0
  44:	e12fff1e 	bx	lr

00000048 <s3c_fimc_suspend>:
}

int s3c_fimc_suspend(struct platform_device *dev, pm_message_t state)
{
	return 0;
}
  48:	e3a00000 	mov	r0, #0
  4c:	e12fff1e 	bx	lr

00000050 <s3c_fimc_resume>:

int s3c_fimc_resume(struct platform_device *dev)
{
	return 0;
}
  50:	e3a00000 	mov	r0, #0
  54:	e12fff1e 	bx	lr

00000058 <s3c_fimc_release>:
	mutex_unlock(&ctrl->lock);
	return ret;
}

static int s3c_fimc_release(struct inode *inode, struct file *filp)
{
  58:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	int id;

	id = MINOR(inode->i_rdev);
	ctrl = &s3c_fimc.ctrl[id];

	mutex_lock(&ctrl->lock);
  5c:	e3a03f8a 	mov	r3, #552	; 0x228
static int s3c_fimc_release(struct inode *inode, struct file *filp)
{
	struct s3c_fimc_control *ctrl;
	int id;

	id = MINOR(inode->i_rdev);
  60:	e5906034 	ldr	r6, [r0, #52]	; 0x34
	ctrl = &s3c_fimc.ctrl[id];

	mutex_lock(&ctrl->lock);
  64:	e59f4054 	ldr	r4, [pc, #84]	; c0 <s3c_fimc_release+0x68>
static int s3c_fimc_release(struct inode *inode, struct file *filp)
{
	struct s3c_fimc_control *ctrl;
	int id;

	id = MINOR(inode->i_rdev);
  68:	e3c664ff 	bic	r6, r6, #-16777216	; 0xff000000
  6c:	e3c6660f 	bic	r6, r6, #15728640	; 0xf00000
	mutex_unlock(&ctrl->lock);
	return ret;
}

static int s3c_fimc_release(struct inode *inode, struct file *filp)
{
  70:	e1a07001 	mov	r7, r1
	int id;

	id = MINOR(inode->i_rdev);
	ctrl = &s3c_fimc.ctrl[id];

	mutex_lock(&ctrl->lock);
  74:	e0060693 	mul	r6, r3, r6
  78:	e2865018 	add	r5, r6, #24
  7c:	e0845005 	add	r5, r4, r5

	atomic_dec(&ctrl->in_use);
  80:	e2866040 	add	r6, r6, #64	; 0x40
	int id;

	id = MINOR(inode->i_rdev);
	ctrl = &s3c_fimc.ctrl[id];

	mutex_lock(&ctrl->lock);
  84:	e1a00005 	mov	r0, r5

	atomic_dec(&ctrl->in_use);
  88:	e0844006 	add	r4, r4, r6
	int id;

	id = MINOR(inode->i_rdev);
	ctrl = &s3c_fimc.ctrl[id];

	mutex_lock(&ctrl->lock);
  8c:	ebfffffe 	bl	0 <mutex_lock>

	atomic_dec(&ctrl->in_use);
  90:	e2843004 	add	r3, r4, #4
static inline void atomic_sub(int i, atomic_t *v)
{
	unsigned long tmp;
	int result;

	__asm__ __volatile__("@ atomic_sub\n"
  94:	e1932f9f 	ldrex	r2, [r3]
  98:	e2422001 	sub	r2, r2, #1
  9c:	e1831f92 	strex	r1, r2, [r3]
  a0:	e3310000 	teq	r1, #0
  a4:	1afffffa 	bne	94 <s3c_fimc_release+0x3c>
	filp->private_data = NULL;
  a8:	e3a04000 	mov	r4, #0

	mutex_unlock(&ctrl->lock);
  ac:	e1a00005 	mov	r0, r5
	ctrl = &s3c_fimc.ctrl[id];

	mutex_lock(&ctrl->lock);

	atomic_dec(&ctrl->in_use);
	filp->private_data = NULL;
  b0:	e5874068 	str	r4, [r7, #104]	; 0x68

	mutex_unlock(&ctrl->lock);
  b4:	ebfffffe 	bl	0 <mutex_unlock>

	return 0;
}
  b8:	e1a00004 	mov	r0, r4
  bc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
  c0:	00000000 	.word	0x00000000

000000c4 <s3c_fimc_mmap>:
	
	return 0;
}

static int s3c_fimc_mmap(struct file* filp, struct vm_area_struct *vma)
{
  c4:	e1a0c001 	mov	ip, r1
  c8:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}

	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
	vma->vm_flags |= VM_RESERVED;

	/* page frame number of the address for a source frame to be stored at. */
	pfn = __phys_to_pfn(frame->addr[vma->vm_pgoff].phys_y);
  cc:	e3a06018 	mov	r6, #24
	return 0;
}

static int s3c_fimc_mmap(struct file* filp, struct vm_area_struct *vma)
{
	struct s3c_fimc_control *ctrl = filp->private_data;
  d0:	e5902068 	ldr	r2, [r0, #104]	; 0x68

	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
	vma->vm_flags |= VM_RESERVED;

	/* page frame number of the address for a source frame to be stored at. */
	pfn = __phys_to_pfn(frame->addr[vma->vm_pgoff].phys_y);
  d4:	e59c5048 	ldr	r5, [ip, #72]	; 0x48
static int s3c_fimc_mmap(struct file* filp, struct vm_area_struct *vma)
{
	struct s3c_fimc_control *ctrl = filp->private_data;
	struct s3c_fimc_out_frame *frame = &ctrl->out_frame;
	
	u32 size = vma->vm_end - vma->vm_start;
  d8:	e5911004 	ldr	r1, [r1, #4]
	u32 pfn, total_size = frame->buf_size;
  dc:	e592e154 	ldr	lr, [r2, #340]	; 0x154
static int s3c_fimc_mmap(struct file* filp, struct vm_area_struct *vma)
{
	struct s3c_fimc_control *ctrl = filp->private_data;
	struct s3c_fimc_out_frame *frame = &ctrl->out_frame;
	
	u32 size = vma->vm_end - vma->vm_start;
  e0:	e59c3008 	ldr	r3, [ip, #8]

	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
	vma->vm_flags |= VM_RESERVED;

	/* page frame number of the address for a source frame to be stored at. */
	pfn = __phys_to_pfn(frame->addr[vma->vm_pgoff].phys_y);
  e4:	e0222596 	mla	r2, r6, r5, r2
	struct s3c_fimc_out_frame *frame = &ctrl->out_frame;
	
	u32 size = vma->vm_end - vma->vm_start;
	u32 pfn, total_size = frame->buf_size;

	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
  e8:	e59c0014 	ldr	r0, [ip, #20]
	vma->vm_flags |= VM_RESERVED;
  ec:	e59c4018 	ldr	r4, [ip, #24]
static int s3c_fimc_mmap(struct file* filp, struct vm_area_struct *vma)
{
	struct s3c_fimc_control *ctrl = filp->private_data;
	struct s3c_fimc_out_frame *frame = &ctrl->out_frame;
	
	u32 size = vma->vm_end - vma->vm_start;
  f0:	e0613003 	rsb	r3, r1, r3
	u32 pfn, total_size = frame->buf_size;

	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
  f4:	e3c0003c 	bic	r0, r0, #60	; 0x3c
	vma->vm_flags |= VM_RESERVED;
  f8:	e3844702 	orr	r4, r4, #524288	; 0x80000

	/* page frame number of the address for a source frame to be stored at. */
	pfn = __phys_to_pfn(frame->addr[vma->vm_pgoff].phys_y);

	if (size > total_size) 
  fc:	e153000e 	cmp	r3, lr
	struct s3c_fimc_out_frame *frame = &ctrl->out_frame;
	
	u32 size = vma->vm_end - vma->vm_start;
	u32 pfn, total_size = frame->buf_size;

	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 100:	e58c0014 	str	r0, [ip, #20]
	vma->vm_flags |= VM_RESERVED;
 104:	e58c4018 	str	r4, [ip, #24]

	/* page frame number of the address for a source frame to be stored at. */
	pfn = __phys_to_pfn(frame->addr[vma->vm_pgoff].phys_y);
 108:	e5922158 	ldr	r2, [r2, #344]	; 0x158

	if (size > total_size) 
 10c:	9a000004 	bls	124 <s3c_fimc_mmap+0x60>
	{
		err("the size of mapping is too big(total_size = %d,size = %d)\n",total_size,size);
 110:	e1a0100e 	mov	r1, lr
 114:	e1a02003 	mov	r2, r3
 118:	e59f003c 	ldr	r0, [pc, #60]	; 15c <s3c_fimc_mmap+0x98>
 11c:	ebfffffe 	bl	0 <printk>
 120:	ea00000b 	b	154 <s3c_fimc_mmap+0x90>
		return -EINVAL;
	}

	if ((vma->vm_flags & VM_WRITE) && !(vma->vm_flags & VM_SHARED)) {
 124:	e204400a 	and	r4, r4, #10
 128:	e3540002 	cmp	r4, #2
		err("writable mapping must be shared\n");
 12c:	059f002c 	ldreq	r0, [pc, #44]	; 160 <s3c_fimc_mmap+0x9c>
	{
		err("the size of mapping is too big(total_size = %d,size = %d)\n",total_size,size);
		return -EINVAL;
	}

	if ((vma->vm_flags & VM_WRITE) && !(vma->vm_flags & VM_SHARED)) {
 130:	0a000006 	beq	150 <s3c_fimc_mmap+0x8c>
		err("writable mapping must be shared\n");
		return -EINVAL;
	}

	if (remap_pfn_range(vma, vma->vm_start, pfn, size, vma->vm_page_prot)) {
 134:	e58d0000 	str	r0, [sp]
 138:	e1a02622 	lsr	r2, r2, #12
 13c:	e1a0000c 	mov	r0, ip
 140:	ebfffffe 	bl	0 <remap_pfn_range>
 144:	e3500000 	cmp	r0, #0
 148:	0a000002 	beq	158 <s3c_fimc_mmap+0x94>
		err("mmap fail\n");
 14c:	e59f0010 	ldr	r0, [pc, #16]	; 164 <s3c_fimc_mmap+0xa0>
 150:	ebfffffe 	bl	0 <printk>
		return -EINVAL;
 154:	e3e00015 	mvn	r0, #21
	}

	return 0;
}
 158:	e8bd807c 	pop	{r2, r3, r4, r5, r6, pc}
 15c:	00000000 	.word	0x00000000
 160:	00000048 	.word	0x00000048
 164:	00000076 	.word	0x00000076

00000168 <s3c_fimc_read>:
	return mask;
}

static
ssize_t s3c_fimc_read(struct file *filp, char *buf, size_t count, loff_t *pos)
{
 168:	e92d45f0 	push	{r4, r5, r6, r7, r8, sl, lr}
 16c:	e1a07001 	mov	r7, r1
	struct s3c_fimc_control *ctrl = filp->private_data;
 170:	e5904068 	ldr	r4, [r0, #104]	; 0x68
	return mask;
}

static
ssize_t s3c_fimc_read(struct file *filp, char *buf, size_t count, loff_t *pos)
{
 174:	e24dd01c 	sub	sp, sp, #28
 178:	e1a05002 	mov	r5, r2
	struct s3c_fimc_control *ctrl = filp->private_data;
	size_t end;
	
	if (IS_CAPTURE(ctrl)) {
 17c:	e5941014 	ldr	r1, [r4, #20]
 180:	e3110020 	tst	r1, #32
 184:	0a00002b 	beq	238 <s3c_fimc_read+0xd0>
		if (wait_event_interruptible(ctrl->waitq, IS_IRQ_HANDLING(ctrl)))
 188:	e2111004 	ands	r1, r1, #4
 18c:	1a000025 	bne	228 <s3c_fimc_read+0xc0>
static inline struct thread_info *current_thread_info(void) __attribute_const__;

static inline struct thread_info *current_thread_info(void)
{
	register unsigned long sp asm ("sp");
	return (struct thread_info *)(sp & ~(THREAD_SIZE - 1));
 190:	e1a0200d 	mov	r2, sp
 194:	e3c26d7f 	bic	r6, r2, #8128	; 0x1fc0
 198:	e3c6603f 	bic	r6, r6, #63	; 0x3f
 19c:	e28d8004 	add	r8, sp, #4

static inline struct task_struct *get_current(void) __attribute_const__;

static inline struct task_struct *get_current(void)
{
	return current_thread_info()->task;
 1a0:	e596a00c 	ldr	sl, [r6, #12]
 1a4:	e1a00008 	mov	r0, r8
 1a8:	e3a02014 	mov	r2, #20
 1ac:	ebfffffe 	bl	0 <memset>
 1b0:	e59f30e0 	ldr	r3, [pc, #224]	; 298 <s3c_fimc_read+0x130>
 1b4:	e58da008 	str	sl, [sp, #8]
 1b8:	e284a030 	add	sl, r4, #48	; 0x30
 1bc:	e58d300c 	str	r3, [sp, #12]
 1c0:	e288300c 	add	r3, r8, #12
 1c4:	e58d3010 	str	r3, [sp, #16]
 1c8:	e58d3014 	str	r3, [sp, #20]
 1cc:	e1a0000a 	mov	r0, sl
 1d0:	e1a01008 	mov	r1, r8
 1d4:	e3a02001 	mov	r2, #1
 1d8:	ebfffffe 	bl	0 <prepare_to_wait>
 1dc:	e5943014 	ldr	r3, [r4, #20]
 1e0:	e3130004 	tst	r3, #4
 1e4:	1a000006 	bne	204 <s3c_fimc_read+0x9c>
	return test_and_clear_ti_thread_flag(task_thread_info(tsk), flag);
}

static inline int test_tsk_thread_flag(struct task_struct *tsk, int flag)
{
	return test_ti_thread_flag(task_thread_info(tsk), flag);
 1e8:	e596300c 	ldr	r3, [r6, #12]
	return test_and_clear_bit(flag, (unsigned long *)&ti->flags);
}

static inline int test_ti_thread_flag(struct thread_info *ti, int flag)
{
	return test_bit(flag, (unsigned long *)&ti->flags);
 1ec:	e5933004 	ldr	r3, [r3, #4]
 * @nr: bit number to test
 * @addr: Address to start counting from
 */
static inline int test_bit(int nr, const volatile unsigned long *addr)
{
	return 1UL & (addr[BIT_WORD(nr)] >> (nr & (BITS_PER_LONG-1)));
 1f0:	e5933000 	ldr	r3, [r3]
 1f4:	e3130001 	tst	r3, #1
 1f8:	1a000003 	bne	20c <s3c_fimc_read+0xa4>
 1fc:	ebfffffe 	bl	0 <schedule>
 200:	eafffff1 	b	1cc <s3c_fimc_read+0x64>
 204:	e3a06000 	mov	r6, #0
 208:	ea000000 	b	210 <s3c_fimc_read+0xa8>
 20c:	e59f6088 	ldr	r6, [pc, #136]	; 29c <s3c_fimc_read+0x134>
 210:	e1a0000a 	mov	r0, sl
 214:	e28d1004 	add	r1, sp, #4
 218:	ebfffffe 	bl	0 <finish_wait>
 21c:	e3560000 	cmp	r6, #0
				return -ERESTARTSYS;
 220:	159f0074 	ldrne	r0, [pc, #116]	; 29c <s3c_fimc_read+0x134>
{
	struct s3c_fimc_control *ctrl = filp->private_data;
	size_t end;
	
	if (IS_CAPTURE(ctrl)) {
		if (wait_event_interruptible(ctrl->waitq, IS_IRQ_HANDLING(ctrl)))
 224:	1a000019 	bne	290 <s3c_fimc_read+0x128>
				return -ERESTARTSYS;

		FSET_STOP(ctrl);
 228:	e5943014 	ldr	r3, [r4, #20]
 22c:	e3c3300f 	bic	r3, r3, #15
 230:	e3833002 	orr	r3, r3, #2
 234:	e5843014 	str	r3, [r4, #20]
	}

	end = min_t(size_t, ctrl->out_frame.buf_size, count);
 238:	e5943154 	ldr	r3, [r4, #340]	; 0x154
	
	if (copy_to_user(buf, s3c_fimc_get_current_frame(ctrl), end))
 23c:	e1a00004 	mov	r0, r4
				return -ERESTARTSYS;

		FSET_STOP(ctrl);
	}

	end = min_t(size_t, ctrl->out_frame.buf_size, count);
 240:	e1550003 	cmp	r5, r3
 244:	21a05003 	movcs	r5, r3
	
	if (copy_to_user(buf, s3c_fimc_get_current_frame(ctrl), end))
 248:	ebfffffe 	bl	0 <s3c_fimc_get_current_frame>
 24c:	e1a0200d 	mov	r2, sp
 250:	e3c23d7f 	bic	r3, r2, #8128	; 0x1fc0
 254:	e3c3303f 	bic	r3, r3, #63	; 0x3f
	return n;
}

static inline unsigned long __must_check copy_to_user(void __user *to, const void *from, unsigned long n)
{
	if (access_ok(VERIFY_WRITE, to, n))
 258:	e5933008 	ldr	r3, [r3, #8]
 25c:	e0972005 	adds	r2, r7, r5
 260:	30d22003 	sbcscc	r2, r2, r3
 264:	33a03000 	movcc	r3, #0
 268:	e3530000 	cmp	r3, #0
 26c:	e1a01000 	mov	r1, r0
 270:	11a00005 	movne	r0, r5
 274:	1a000002 	bne	284 <s3c_fimc_read+0x11c>
		n = __copy_to_user(to, from, n);
 278:	e1a00007 	mov	r0, r7
 27c:	e1a02005 	mov	r2, r5
 280:	ebfffffe 	bl	0 <__copy_to_user>
		return -EFAULT;
	
	return end;
 284:	e3500000 	cmp	r0, #0
 288:	01a00005 	moveq	r0, r5
 28c:	13e0000d 	mvnne	r0, #13
}
 290:	e28dd01c 	add	sp, sp, #28
 294:	e8bd85f0 	pop	{r4, r5, r6, r7, r8, sl, pc}
 298:	00000000 	.word	0x00000000
 29c:	fffffe00 	.word	0xfffffe00

000002a0 <s3c_fimc_register>:
		.name	= "s3c-fimc",
		.owner	= THIS_MODULE,
	},
};
static int s3c_fimc_register(void)
{
 2a0:	e92d4008 	push	{r3, lr}
printk("=============fimc register \n");//hnmsky
 2a4:	e59f0010 	ldr	r0, [pc, #16]	; 2bc <s3c_fimc_register+0x1c>
 2a8:	ebfffffe 	bl	0 <printk>
	platform_driver_register(&s3c_fimc_driver);
 2ac:	e59f000c 	ldr	r0, [pc, #12]	; 2c0 <s3c_fimc_register+0x20>
 2b0:	ebfffffe 	bl	0 <platform_driver_register>
   
	return 0;
}
 2b4:	e3a00000 	mov	r0, #0
 2b8:	e8bd8008 	pop	{r3, pc}
 2bc:	0000008e 	.word	0x0000008e
 2c0:	00000000 	.word	0x00000000

000002c4 <s3c_fimc_irq>:
		cam->initialized = 1;
	}
}

static irqreturn_t s3c_fimc_irq(int irq, void *dev_id)
{
 2c4:	e92d4010 	push	{r4, lr}
	struct s3c_fimc_control *ctrl = (struct s3c_fimc_control *) dev_id;

	s3c_fimc_clear_irq(ctrl);
 2c8:	e1a00001 	mov	r0, r1
		cam->initialized = 1;
	}
}

static irqreturn_t s3c_fimc_irq(int irq, void *dev_id)
{
 2cc:	e1a04001 	mov	r4, r1
	struct s3c_fimc_control *ctrl = (struct s3c_fimc_control *) dev_id;

	s3c_fimc_clear_irq(ctrl);
 2d0:	ebfffffe 	bl	0 <s3c_fimc_clear_irq>
	s3c_fimc_check_fifo(ctrl);
 2d4:	e1a00004 	mov	r0, r4
 2d8:	ebfffffe 	bl	0 <s3c_fimc_check_fifo>

	if (IS_CAPTURE(ctrl)) {
 2dc:	e5943014 	ldr	r3, [r4, #20]
 2e0:	e3130020 	tst	r3, #32
 2e4:	0a00000c 	beq	31c <s3c_fimc_irq+0x58>
		dev_dbg(ctrl->dev, "irq is in capture state\n");
 2e8:	e5941038 	ldr	r1, [r4, #56]	; 0x38
 2ec:	e59f2030 	ldr	r2, [pc, #48]	; 324 <s3c_fimc_irq+0x60>
 2f0:	e59f0030 	ldr	r0, [pc, #48]	; 328 <s3c_fimc_irq+0x64>
 2f4:	ebfffffe 	bl	0 <dev_printk>

		if (s3c_fimc_frame_handler(ctrl) == S3C_FIMC_FRAME_SKIP)
 2f8:	e1a00004 	mov	r0, r4
 2fc:	ebfffffe 	bl	0 <s3c_fimc_frame_handler>
 300:	e3500000 	cmp	r0, #0
 304:	0a000004 	beq	31c <s3c_fimc_irq+0x58>
			return IRQ_HANDLED;

		wake_up_interruptible(&ctrl->waitq);
 308:	e3a01001 	mov	r1, #1
 30c:	e2840030 	add	r0, r4, #48	; 0x30
 310:	e1a02001 	mov	r2, r1
 314:	e3a03000 	mov	r3, #0
 318:	ebfffffe 	bl	0 <__wake_up>
	}

	return IRQ_HANDLED;
}
 31c:	e3a00001 	mov	r0, #1
 320:	e8bd8010 	pop	{r4, pc}
 324:	000000af 	.word	0x000000af
 328:	000000ab 	.word	0x000000ab

0000032c <s3c_fimc_unregister>:
	return 0;
}

static void s3c_fimc_unregister(void)
{
	platform_driver_unregister(&s3c_fimc_driver);
 32c:	e59f0000 	ldr	r0, [pc, #0]	; 334 <s3c_fimc_unregister+0x8>
 330:	eafffffe 	b	0 <platform_driver_unregister>
 334:	00000000 	.word	0x00000000

00000338 <s3c_fimc_vdev_release>:
	.poll = s3c_fimc_poll,
};

static void s3c_fimc_vdev_release(struct video_device *vdev)
{
	kfree(vdev);
 338:	eafffffe 	b	0 <kfree>

0000033c <s3c_fimc_unregister_controller.clone.0>:
{
	struct s3c_fimc_control *ctrl;
	struct s3c_platform_fimc *pdata;
	int id = pdev->id;

	ctrl = &s3c_fimc.ctrl[id];
 33c:	e3a02f8a 	mov	r2, #552	; 0x228
 340:	e59f3044 	ldr	r3, [pc, #68]	; 38c <s3c_fimc_unregister_controller.clone.0+0x50>
 344:	e0020092 	mul	r2, r2, r0
	s3c_fimc_set_active_camera(ctrl, 0);

	return ctrl;
}

static int s3c_fimc_unregister_controller(struct platform_device *pdev)
 348:	e92d4010 	push	{r4, lr}
{
	struct s3c_fimc_control *ctrl;
	struct s3c_platform_fimc *pdata;
	int id = pdev->id;

	ctrl = &s3c_fimc.ctrl[id];
 34c:	e0834002 	add	r4, r3, r2

	s3c_fimc_free_output_memory(&ctrl->out_frame);
 350:	e2822e15 	add	r2, r2, #336	; 0x150
 354:	e0830002 	add	r0, r3, r2
 358:	ebfffffe 	bl	0 <s3c_fimc_free_output_memory>

struct s3c_platform_fimc *to_fimc_plat(struct device *dev)
{
	struct platform_device *pdev = to_platform_device(dev);

	return (struct s3c_platform_fimc *) pdev->dev.platform_data;
 35c:	e5943038 	ldr	r3, [r4, #56]	; 0x38

	s3c_fimc_free_output_memory(&ctrl->out_frame);

	pdata = to_fimc_plat(ctrl->dev);

	if (!pdata->shared_io)
 360:	e5933054 	ldr	r3, [r3, #84]	; 0x54
 364:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
 368:	e3530000 	cmp	r3, #0
 36c:	1a000001 	bne	378 <s3c_fimc_unregister_controller.clone.0+0x3c>
		iounmap(ctrl->regs);
 370:	e5940040 	ldr	r0, [r4, #64]	; 0x40
 374:	ebfffffe 	bl	0 <__iounmap>

	memset(ctrl, 0, sizeof(*ctrl));
 378:	e1a00004 	mov	r0, r4
 37c:	e3a01f8a 	mov	r1, #552	; 0x228
 380:	ebfffffe 	bl	0 <__memzero>
	
	return 0;
}
 384:	e3a00000 	mov	r0, #0
 388:	e8bd8010 	pop	{r4, pc}
 38c:	00000000 	.word	0x00000000

00000390 <s3c_fimc_remove>:
	return -EINVAL;
	
}

static int s3c_fimc_remove(struct platform_device *pdev)
{
 390:	e92d4008 	push	{r3, lr}
	s3c_fimc_unregister_controller(pdev);
 394:	e5900004 	ldr	r0, [r0, #4]
 398:	ebffffe7 	bl	33c <s3c_fimc_unregister_controller.clone.0>

	return 0;
}
 39c:	e3a00000 	mov	r0, #0
 3a0:	e8bd8008 	pop	{r3, pc}

000003a4 <to_fimc_plat>:
struct s3c_platform_fimc *to_fimc_plat(struct device *dev)
{
	struct platform_device *pdev = to_platform_device(dev);

	return (struct s3c_platform_fimc *) pdev->dev.platform_data;
}
 3a4:	e5900054 	ldr	r0, [r0, #84]	; 0x54
 3a8:	e12fff1e 	bx	lr

000003ac <s3c_fimc_i2c_read>:

u8 s3c_fimc_i2c_read(struct i2c_client *client, u8 subaddr)
{
 3ac:	e92d4030 	push	{r4, r5, lr}
 3b0:	e24dd014 	sub	sp, sp, #20
	u8 buf[1];
	struct i2c_msg msg = {client->addr, 0, 1, buf};
 3b4:	e1d030b2 	ldrh	r3, [r0, #2]
	int ret;
	
	buf[0] = subaddr;
 3b8:	e5cd100c 	strb	r1, [sp, #12]

	ret = i2c_transfer(client->adapter, &msg, 1) == 1 ? 0 : -EIO;
 3bc:	e3a02001 	mov	r2, #1
}

u8 s3c_fimc_i2c_read(struct i2c_client *client, u8 subaddr)
{
	u8 buf[1];
	struct i2c_msg msg = {client->addr, 0, 1, buf};
 3c0:	e1cd30b0 	strh	r3, [sp]
 3c4:	e3a03000 	mov	r3, #0
 3c8:	e1cd30b2 	strh	r3, [sp, #2]
 3cc:	e3a03001 	mov	r3, #1
 3d0:	e1cd30b4 	strh	r3, [sp, #4]

	return (struct s3c_platform_fimc *) pdev->dev.platform_data;
}

u8 s3c_fimc_i2c_read(struct i2c_client *client, u8 subaddr)
{
 3d4:	e1a04000 	mov	r4, r0
	u8 buf[1];
	struct i2c_msg msg = {client->addr, 0, 1, buf};
 3d8:	e28d300c 	add	r3, sp, #12
	int ret;
	
	buf[0] = subaddr;

	ret = i2c_transfer(client->adapter, &msg, 1) == 1 ? 0 : -EIO;
 3dc:	e5900018 	ldr	r0, [r0, #24]
 3e0:	e1a0100d 	mov	r1, sp
}

u8 s3c_fimc_i2c_read(struct i2c_client *client, u8 subaddr)
{
	u8 buf[1];
	struct i2c_msg msg = {client->addr, 0, 1, buf};
 3e4:	e58d3008 	str	r3, [sp, #8]
	int ret;
	
	buf[0] = subaddr;

	ret = i2c_transfer(client->adapter, &msg, 1) == 1 ? 0 : -EIO;
 3e8:	ebfffffe 	bl	0 <i2c_transfer>
 3ec:	e1a0500d 	mov	r5, sp
 3f0:	e3500001 	cmp	r0, #1
 3f4:	e1a02000 	mov	r2, r0
 3f8:	1a000006 	bne	418 <s3c_fimc_i2c_read+0x6c>
	if (ret == -EIO) {
		err("i2c transfer error\n");
		return -EIO;
	}

	msg.flags = I2C_M_RD;
 3fc:	e1cd00b2 	strh	r0, [sp, #2]
	ret = i2c_transfer(client->adapter, &msg, 1) == 1 ? 0 : -EIO;
 400:	e1a0100d 	mov	r1, sp
 404:	e5940018 	ldr	r0, [r4, #24]
 408:	ebfffffe 	bl	0 <i2c_transfer>

	return buf[0];
 40c:	e5dd000c 	ldrb	r0, [sp, #12]
}
 410:	e28dd014 	add	sp, sp, #20
 414:	e8bd8030 	pop	{r4, r5, pc}
	
	buf[0] = subaddr;

	ret = i2c_transfer(client->adapter, &msg, 1) == 1 ? 0 : -EIO;
	if (ret == -EIO) {
		err("i2c transfer error\n");
 418:	e59f0008 	ldr	r0, [pc, #8]	; 428 <s3c_fimc_i2c_read+0x7c>
 41c:	ebfffffe 	bl	0 <printk>
		return -EIO;
 420:	e3a000fb 	mov	r0, #251	; 0xfb
 424:	eafffff9 	b	410 <s3c_fimc_i2c_read+0x64>
 428:	000000c8 	.word	0x000000c8

0000042c <s3c_fimc_i2c_write>:

	return buf[0];
}

int s3c_fimc_i2c_write(struct i2c_client *client, u8 i2c_data[], u8 length)
{
 42c:	e92d4800 	push	{fp, lr}
 430:	e28db004 	add	fp, sp, #4
 434:	e24dd010 	sub	sp, sp, #16
	u8 buf[length];
 438:	e282300e 	add	r3, r2, #14
	u8 i;
	struct i2c_msg msg = {client->addr, 0, length, buf};
 43c:	e1d0c0b2 	ldrh	ip, [r0, #2]
	return buf[0];
}

int s3c_fimc_i2c_write(struct i2c_client *client, u8 i2c_data[], u8 length)
{
	u8 buf[length];
 440:	e2033f7e 	and	r3, r3, #504	; 0x1f8
 444:	e04dd003 	sub	sp, sp, r3
	u8 i;
	struct i2c_msg msg = {client->addr, 0, length, buf};
 448:	e14bc1b0 	strh	ip, [fp, #-16]
 44c:	e3a0c000 	mov	ip, #0
 450:	e14bc0be 	strh	ip, [fp, #-14]
	return buf[0];
}

int s3c_fimc_i2c_write(struct i2c_client *client, u8 i2c_data[], u8 length)
{
	u8 buf[length];
 454:	e1a0300d 	mov	r3, sp
	u8 i;
	struct i2c_msg msg = {client->addr, 0, length, buf};
 458:	e14b20bc 	strh	r2, [fp, #-12]
 45c:	e50bd008 	str	sp, [fp, #-8]

	for ( i=0; i<length; i++ ) {
 460:	e3a0c000 	mov	ip, #0
 464:	ea000002 	b	474 <s3c_fimc_i2c_write+0x48>
		buf[i] = i2c_data[i];
 468:	e4d1e001 	ldrb	lr, [r1], #1
 46c:	e7c3e00c 	strb	lr, [r3, ip]
 470:	e28cc001 	add	ip, ip, #1
{
	u8 buf[length];
	u8 i;
	struct i2c_msg msg = {client->addr, 0, length, buf};

	for ( i=0; i<length; i++ ) {
 474:	e6efe07c 	uxtb	lr, ip
 478:	e15e0002 	cmp	lr, r2
 47c:	3afffff9 	bcc	468 <s3c_fimc_i2c_write+0x3c>
		buf[i] = i2c_data[i];
	}
	return i2c_transfer(client->adapter, &msg, 1) == 1 ? 0 : -EIO;
 480:	e24b1010 	sub	r1, fp, #16
 484:	e3a02001 	mov	r2, #1
 488:	e5900018 	ldr	r0, [r0, #24]
 48c:	ebfffffe 	bl	0 <i2c_transfer>
 490:	e3500001 	cmp	r0, #1
}
 494:	13e00004 	mvnne	r0, #4
 498:	03a00000 	moveq	r0, #0
 49c:	e24bd004 	sub	sp, fp, #4
 4a0:	e8bd8800 	pop	{fp, pc}

000004a4 <s3c_fimc_i2c_command>:

void s3c_fimc_i2c_command(struct s3c_fimc_control *ctrl, u32 cmd, int arg)
{
 4a4:	e92d4010 	push	{r4, lr}
	struct i2c_client *client = ctrl->in_cam->client;
 4a8:	e59030f8 	ldr	r3, [r0, #248]	; 0xf8
 4ac:	e593003c 	ldr	r0, [r3, #60]	; 0x3c

	if (client)
 4b0:	e3500000 	cmp	r0, #0
 4b4:	0a000003 	beq	4c8 <s3c_fimc_i2c_command+0x24>
		client->driver->command(client, cmd, (void *) arg);
 4b8:	e590301c 	ldr	r3, [r0, #28]
 4bc:	e5933024 	ldr	r3, [r3, #36]	; 0x24
 4c0:	e12fff33 	blx	r3
	else
		err("i2c client is not registered\n");
}
 4c4:	e8bd8010 	pop	{r4, pc}
	struct i2c_client *client = ctrl->in_cam->client;

	if (client)
		client->driver->command(client, cmd, (void *) arg);
	else
		err("i2c client is not registered\n");
 4c8:	e59f0004 	ldr	r0, [pc, #4]	; 4d4 <s3c_fimc_i2c_command+0x30>
}
 4cc:	e8bd4010 	pop	{r4, lr}
	struct i2c_client *client = ctrl->in_cam->client;

	if (client)
		client->driver->command(client, cmd, (void *) arg);
	else
		err("i2c client is not registered\n");
 4d0:	eafffffe 	b	0 <printk>
 4d4:	000000e9 	.word	0x000000e9

000004d8 <s3c_fimc_register_camera>:
}

void s3c_fimc_register_camera(struct s3c_fimc_camera *cam)
{
 4d8:	e92d4070 	push	{r4, r5, r6, lr}
 4dc:	e1a05000 	mov	r5, r0
	s3c_fimc.camera[cam->id] = cam;
 4e0:	e5903000 	ldr	r3, [r0]
 4e4:	e59f4028 	ldr	r4, [pc, #40]	; 514 <s3c_fimc_register_camera+0x3c>
 4e8:	e0843103 	add	r3, r4, r3, lsl #2
 4ec:	e5830678 	str	r0, [r3, #1656]	; 0x678

	clk_disable(s3c_fimc.cam_clock);
 4f0:	e5940688 	ldr	r0, [r4, #1672]	; 0x688
 4f4:	ebfffffe 	bl	0 <clk_disable>
	clk_set_rate(s3c_fimc.cam_clock, cam->clockrate);
 4f8:	e5951010 	ldr	r1, [r5, #16]
 4fc:	e5940688 	ldr	r0, [r4, #1672]	; 0x688
 500:	ebfffffe 	bl	0 <clk_set_rate>
	clk_enable(s3c_fimc.cam_clock);
 504:	e5940688 	ldr	r0, [r4, #1672]	; 0x688
 508:	ebfffffe 	bl	0 <clk_enable>

	s3c_fimc_reset_camera();
}
 50c:	e8bd4070 	pop	{r4, r5, r6, lr}

	clk_disable(s3c_fimc.cam_clock);
	clk_set_rate(s3c_fimc.cam_clock, cam->clockrate);
	clk_enable(s3c_fimc.cam_clock);

	s3c_fimc_reset_camera();
 510:	eafffffe 	b	0 <s3c_fimc_reset_camera>
 514:	00000000 	.word	0x00000000

00000518 <s3c_fimc_unregister_camera>:
void s3c_fimc_unregister_camera(struct s3c_fimc_camera *cam)
{
	int i = 0;

	for (i = 0; i < S3C_FIMC_MAX_CTRLS; i++) {
		if (s3c_fimc.ctrl[i].in_cam == cam)
 518:	e59f3050 	ldr	r3, [pc, #80]	; 570 <s3c_fimc_unregister_camera+0x58>
			s3c_fimc.ctrl[i].in_cam = NULL;
	}
	
	s3c_fimc.camera[cam->id] = NULL;
 51c:	e3a01000 	mov	r1, #0
void s3c_fimc_unregister_camera(struct s3c_fimc_camera *cam)
{
	int i = 0;

	for (i = 0; i < S3C_FIMC_MAX_CTRLS; i++) {
		if (s3c_fimc.ctrl[i].in_cam == cam)
 520:	e59320f8 	ldr	r2, [r3, #248]	; 0xf8
 524:	e1520000 	cmp	r2, r0
			s3c_fimc.ctrl[i].in_cam = NULL;
 528:	03a02000 	moveq	r2, #0
 52c:	058320f8 	streq	r2, [r3, #248]	; 0xf8
void s3c_fimc_unregister_camera(struct s3c_fimc_camera *cam)
{
	int i = 0;

	for (i = 0; i < S3C_FIMC_MAX_CTRLS; i++) {
		if (s3c_fimc.ctrl[i].in_cam == cam)
 530:	e59f3038 	ldr	r3, [pc, #56]	; 570 <s3c_fimc_unregister_camera+0x58>
 534:	e5932320 	ldr	r2, [r3, #800]	; 0x320
 538:	e1520000 	cmp	r2, r0
			s3c_fimc.ctrl[i].in_cam = NULL;
 53c:	03a02000 	moveq	r2, #0
 540:	05832320 	streq	r2, [r3, #800]	; 0x320
void s3c_fimc_unregister_camera(struct s3c_fimc_camera *cam)
{
	int i = 0;

	for (i = 0; i < S3C_FIMC_MAX_CTRLS; i++) {
		if (s3c_fimc.ctrl[i].in_cam == cam)
 544:	e59f3024 	ldr	r3, [pc, #36]	; 570 <s3c_fimc_unregister_camera+0x58>
 548:	e5932548 	ldr	r2, [r3, #1352]	; 0x548
 54c:	e1520000 	cmp	r2, r0
			s3c_fimc.ctrl[i].in_cam = NULL;
 550:	03a02000 	moveq	r2, #0
 554:	05832548 	streq	r2, [r3, #1352]	; 0x548
	}
	
	s3c_fimc.camera[cam->id] = NULL;
 558:	e5902000 	ldr	r2, [r0]
 55c:	e59f300c 	ldr	r3, [pc, #12]	; 570 <s3c_fimc_unregister_camera+0x58>
 560:	e2822f67 	add	r2, r2, #412	; 0x19c
 564:	e2822002 	add	r2, r2, #2
 568:	e7831102 	str	r1, [r3, r2, lsl #2]
}
 56c:	e12fff1e 	bx	lr
 570:	00000000 	.word	0x00000000

00000574 <s3c_fimc_set_active_camera>:

void s3c_fimc_set_active_camera(struct s3c_fimc_control *ctrl, int id)
{
	ctrl->in_cam = s3c_fimc.camera[id];
 574:	e59f3024 	ldr	r3, [pc, #36]	; 5a0 <s3c_fimc_set_active_camera+0x2c>
 578:	e0833101 	add	r3, r3, r1, lsl #2
 57c:	e5933678 	ldr	r3, [r3, #1656]	; 0x678
 580:	e58030f8 	str	r3, [r0, #248]	; 0xf8

	if (ctrl->in_cam && id < S3C_FIMC_TPID)
 584:	e2533000 	subs	r3, r3, #0
 588:	13a03001 	movne	r3, #1
 58c:	e3510002 	cmp	r1, #2
 590:	c3a03000 	movgt	r3, #0
 594:	e3530000 	cmp	r3, #0
 598:	012fff1e 	bxeq	lr
		s3c_fimc_select_camera(ctrl);
 59c:	eafffffe 	b	0 <s3c_fimc_select_camera>
 5a0:	00000000 	.word	0x00000000

000005a4 <s3c_fimc_open>:
{
	return 0;
}

static int s3c_fimc_open(struct inode *inode, struct file *filp)
{
 5a4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	int id, ret;

	id = MINOR(inode->i_rdev);
	ctrl = &s3c_fimc.ctrl[id];

	mutex_lock(&ctrl->lock);
 5a8:	e3a03f8a 	mov	r3, #552	; 0x228
static int s3c_fimc_open(struct inode *inode, struct file *filp)
{
	struct s3c_fimc_control *ctrl;
	int id, ret;

	id = MINOR(inode->i_rdev);
 5ac:	e5906034 	ldr	r6, [r0, #52]	; 0x34
	ctrl = &s3c_fimc.ctrl[id];

	mutex_lock(&ctrl->lock);
 5b0:	e59f8084 	ldr	r8, [pc, #132]	; 63c <s3c_fimc_open+0x98>
static int s3c_fimc_open(struct inode *inode, struct file *filp)
{
	struct s3c_fimc_control *ctrl;
	int id, ret;

	id = MINOR(inode->i_rdev);
 5b4:	e3c664ff 	bic	r6, r6, #-16777216	; 0xff000000
 5b8:	e3c6660f 	bic	r6, r6, #15728640	; 0xf00000
{
	return 0;
}

static int s3c_fimc_open(struct inode *inode, struct file *filp)
{
 5bc:	e1a07001 	mov	r7, r1
	int id, ret;

	id = MINOR(inode->i_rdev);
	ctrl = &s3c_fimc.ctrl[id];

	mutex_lock(&ctrl->lock);
 5c0:	e0060693 	mul	r6, r3, r6
 5c4:	e2864018 	add	r4, r6, #24
 5c8:	e0884004 	add	r4, r8, r4
 5cc:	e1a00004 	mov	r0, r4
 5d0:	ebfffffe 	bl	0 <mutex_lock>

	if (atomic_read(&ctrl->in_use)) {
 5d4:	e2863040 	add	r3, r6, #64	; 0x40
 5d8:	e0883003 	add	r3, r8, r3
 5dc:	e2832004 	add	r2, r3, #4
 5e0:	e5935004 	ldr	r5, [r3, #4]
 5e4:	e3550000 	cmp	r5, #0
 5e8:	1a00000f 	bne	62c <s3c_fimc_open+0x88>
{
	struct s3c_fimc_control *ctrl;
	int id, ret;

	id = MINOR(inode->i_rdev);
	ctrl = &s3c_fimc.ctrl[id];
 5ec:	e0886006 	add	r6, r8, r6
static inline void atomic_add(int i, atomic_t *v)
{
	unsigned long tmp;
	int result;

	__asm__ __volatile__("@ atomic_add\n"
 5f0:	e1921f9f 	ldrex	r1, [r2]
 5f4:	e2811001 	add	r1, r1, #1
 5f8:	e1820f91 	strex	r0, r1, [r2]
 5fc:	e3300000 	teq	r0, #0
 600:	1afffffa 	bne	5f0 <s3c_fimc_open+0x4c>
	if (atomic_read(&ctrl->in_use)) {
		ret = -EBUSY;
		goto resource_busy;
	} else {
		atomic_inc(&ctrl->in_use);
		s3c_fimc_reset(ctrl);
 604:	e1a00006 	mov	r0, r6
 608:	ebfffffe 	bl	0 <s3c_fimc_reset>
		s3c_fimc_set_active_camera(ctrl, 0);
 60c:	e1a00006 	mov	r0, r6
 610:	e1a01005 	mov	r1, r5
 614:	ebfffffe 	bl	574 <s3c_fimc_set_active_camera>
		filp->private_data = ctrl;
	}

	mutex_unlock(&ctrl->lock);
 618:	e1a00004 	mov	r0, r4
		goto resource_busy;
	} else {
		atomic_inc(&ctrl->in_use);
		s3c_fimc_reset(ctrl);
		s3c_fimc_set_active_camera(ctrl, 0);
		filp->private_data = ctrl;
 61c:	e5876068 	str	r6, [r7, #104]	; 0x68
	}

	mutex_unlock(&ctrl->lock);
 620:	ebfffffe 	bl	0 <mutex_unlock>

	return 0;
 624:	e1a00005 	mov	r0, r5
 628:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

resource_busy:
	mutex_unlock(&ctrl->lock);
 62c:	e1a00004 	mov	r0, r4
 630:	ebfffffe 	bl	0 <mutex_unlock>
	return ret;
 634:	e3e0000f 	mvn	r0, #15
}
 638:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
 63c:	00000000 	.word	0x00000000

00000640 <s3c_fimc_probe>:

	return 0;
}

static int s3c_fimc_probe(struct platform_device *pdev)
{
 640:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 644:	e1a06000 	mov	r6, r0
 648:	e24dd014 	sub	sp, sp, #20
	struct s3c_platform_fimc *pdata;
	struct s3c_fimc_control *ctrl;
	struct clk *srclk;
	int ret;
printk("=============fimc probe \n");//hnmsky
 64c:	e59f0380 	ldr	r0, [pc, #896]	; 9d4 <s3c_fimc_probe+0x394>
 650:	ebfffffe 	bl	0 <printk>
{
	struct s3c_platform_fimc *pdata;
	struct s3c_fimc_control *ctrl;
	struct resource *res;
	int i = S3C_FIMC_MAX_CTRLS - 1;
	int id = pdev->id;
 654:	e5965004 	ldr	r5, [r6, #4]

	pdata = to_fimc_plat(&pdev->dev);

	ctrl = &s3c_fimc.ctrl[id];
	ctrl->id = id;
 658:	e3a0af8a 	mov	sl, #552	; 0x228
	ctrl->dev = &pdev->dev;
	ctrl->vd = &s3c_fimc_video_device[id];
 65c:	e3a02e13 	mov	r2, #304	; 0x130
 660:	e59f3370 	ldr	r3, [pc, #880]	; 9d8 <s3c_fimc_probe+0x398>
	int id = pdev->id;

	pdata = to_fimc_plat(&pdev->dev);

	ctrl = &s3c_fimc.ctrl[id];
	ctrl->id = id;
 664:	e00a059a 	mul	sl, sl, r5
 668:	e59f836c 	ldr	r8, [pc, #876]	; 9dc <s3c_fimc_probe+0x39c>
	ctrl->dev = &pdev->dev;
	ctrl->vd = &s3c_fimc_video_device[id];
 66c:	e0233592 	mla	r3, r2, r5, r3

struct s3c_platform_fimc *to_fimc_plat(struct device *dev)
{
	struct platform_device *pdev = to_platform_device(dev);

	return (struct s3c_platform_fimc *) pdev->dev.platform_data;
 670:	e596705c 	ldr	r7, [r6, #92]	; 0x5c
	int id = pdev->id;

	pdata = to_fimc_plat(&pdev->dev);

	ctrl = &s3c_fimc.ctrl[id];
	ctrl->id = id;
 674:	e088400a 	add	r4, r8, sl
	ctrl->dev = &pdev->dev;
	ctrl->vd = &s3c_fimc_video_device[id];
	ctrl->rot90 = 0;
 678:	e3a09000 	mov	r9, #0
	struct s3c_fimc_control *ctrl;
	struct resource *res;
	int i = S3C_FIMC_MAX_CTRLS - 1;
	int id = pdev->id;

	pdata = to_fimc_plat(&pdev->dev);
 67c:	e286b008 	add	fp, r6, #8

	ctrl = &s3c_fimc.ctrl[id];
	ctrl->id = id;
 680:	e788500a 	str	r5, [r8, sl]
	ctrl->dev = &pdev->dev;
 684:	e584b038 	str	fp, [r4, #56]	; 0x38
	ctrl->vd = &s3c_fimc_video_device[id];
 688:	e584304c 	str	r3, [r4, #76]	; 0x4c
	ctrl->rot90 = 0;
 68c:	e584921c 	str	r9, [r4, #540]	; 0x21c
	ctrl->vd->minor = id;
 690:	e58350fc 	str	r5, [r3, #252]	; 0xfc
	ctrl->out_frame.nr_frames = pdata->nr_frames;
 694:	e5973028 	ldr	r3, [r7, #40]	; 0x28
	ctrl->out_frame.skip_frames = 0;
 698:	e58491bc 	str	r9, [r4, #444]	; 0x1bc
	ctrl->id = id;
	ctrl->dev = &pdev->dev;
	ctrl->vd = &s3c_fimc_video_device[id];
	ctrl->rot90 = 0;
	ctrl->vd->minor = id;
	ctrl->out_frame.nr_frames = pdata->nr_frames;
 69c:	e58431b8 	str	r3, [r4, #440]	; 0x1b8
	ctrl->out_frame.skip_frames = 0;
	ctrl->scaler.line_length = pdata->line_length;
 6a0:	e5973024 	ldr	r3, [r7, #36]	; 0x24

	sprintf(ctrl->name, "%s%d", S3C_FIMC_NAME, id);
 6a4:	e59f2334 	ldr	r2, [pc, #820]	; 9e0 <s3c_fimc_probe+0x3a0>
	ctrl->vd = &s3c_fimc_video_device[id];
	ctrl->rot90 = 0;
	ctrl->vd->minor = id;
	ctrl->out_frame.nr_frames = pdata->nr_frames;
	ctrl->out_frame.skip_frames = 0;
	ctrl->scaler.line_length = pdata->line_length;
 6a8:	e58430ec 	str	r3, [r4, #236]	; 0xec

	sprintf(ctrl->name, "%s%d", S3C_FIMC_NAME, id);
 6ac:	e2843004 	add	r3, r4, #4
 6b0:	e58d300c 	str	r3, [sp, #12]
 6b4:	e1a00003 	mov	r0, r3
 6b8:	e59f1324 	ldr	r1, [pc, #804]	; 9e4 <s3c_fimc_probe+0x3a4>
 6bc:	e1a03005 	mov	r3, r5
 6c0:	ebfffffe 	bl	0 <sprintf>
	strcpy(ctrl->vd->name, ctrl->name);
 6c4:	e594004c 	ldr	r0, [r4, #76]	; 0x4c
 6c8:	e59d100c 	ldr	r1, [sp, #12]
 6cc:	e28000d8 	add	r0, r0, #216	; 0xd8
 6d0:	ebfffffe 	bl	0 <strcpy>

	ctrl->open_lcdfifo = s3cfb_enable_local;
 6d4:	e59f330c 	ldr	r3, [pc, #780]	; 9e8 <s3c_fimc_probe+0x3a8>
	ctrl->close_lcdfifo = s3cfb_enable_dma;

	atomic_set(&ctrl->in_use, 0);
	mutex_init(&ctrl->lock);
 6d8:	e28a0018 	add	r0, sl, #24
	ctrl->scaler.line_length = pdata->line_length;

	sprintf(ctrl->name, "%s%d", S3C_FIMC_NAME, id);
	strcpy(ctrl->vd->name, ctrl->name);

	ctrl->open_lcdfifo = s3cfb_enable_local;
 6dc:	e5843220 	str	r3, [r4, #544]	; 0x220
	ctrl->close_lcdfifo = s3cfb_enable_dma;
 6e0:	e59f3304 	ldr	r3, [pc, #772]	; 9ec <s3c_fimc_probe+0x3ac>

	atomic_set(&ctrl->in_use, 0);
	mutex_init(&ctrl->lock);
 6e4:	e59f2304 	ldr	r2, [pc, #772]	; 9f0 <s3c_fimc_probe+0x3b0>

	sprintf(ctrl->name, "%s%d", S3C_FIMC_NAME, id);
	strcpy(ctrl->vd->name, ctrl->name);

	ctrl->open_lcdfifo = s3cfb_enable_local;
	ctrl->close_lcdfifo = s3cfb_enable_dma;
 6e8:	e5843224 	str	r3, [r4, #548]	; 0x224

	atomic_set(&ctrl->in_use, 0);
	mutex_init(&ctrl->lock);
 6ec:	e0880000 	add	r0, r8, r0
 6f0:	e59f12fc 	ldr	r1, [pc, #764]	; 9f4 <s3c_fimc_probe+0x3b4>
	strcpy(ctrl->vd->name, ctrl->name);

	ctrl->open_lcdfifo = s3cfb_enable_local;
	ctrl->close_lcdfifo = s3cfb_enable_dma;

	atomic_set(&ctrl->in_use, 0);
 6f4:	e5849044 	str	r9, [r4, #68]	; 0x44
	mutex_init(&ctrl->lock);
 6f8:	ebfffffe 	bl	0 <__mutex_init>
	init_waitqueue_head(&ctrl->waitq);
 6fc:	e28a0030 	add	r0, sl, #48	; 0x30
 700:	e0880000 	add	r0, r8, r0
 704:	e59f12e4 	ldr	r1, [pc, #740]	; 9f0 <s3c_fimc_probe+0x3b0>
 708:	ebfffffe 	bl	0 <__init_waitqueue_head>

	/* get resource for io memory */
	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 70c:	e1a00006 	mov	r0, r6
 710:	e3a01c02 	mov	r1, #512	; 0x200
 714:	e1a02009 	mov	r2, r9
 718:	ebfffffe 	bl	0 <platform_get_resource>
	if (!res) {
 71c:	e3500000 	cmp	r0, #0
		err("failed to get io memory region\n");
 720:	059f02d0 	ldreq	r0, [pc, #720]	; 9f8 <s3c_fimc_probe+0x3b8>
	mutex_init(&ctrl->lock);
	init_waitqueue_head(&ctrl->waitq);

	/* get resource for io memory */
	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if (!res) {
 724:	0a000023 	beq	7b8 <s3c_fimc_probe+0x178>
		err("failed to get io memory region\n");
		return NULL;
	}

	if (!pdata->shared_io) {
 728:	e597702c 	ldr	r7, [r7, #44]	; 0x2c
 72c:	e3570000 	cmp	r7, #0
	s3c_fimc.camera[test_pattern.id] = &test_pattern;

	return 0;
}

static int s3c_fimc_probe(struct platform_device *pdev)
 730:	159f32c4 	ldrne	r3, [pc, #708]	; 9fc <s3c_fimc_probe+0x3bc>
	if (!res) {
		err("failed to get io memory region\n");
		return NULL;
	}

	if (!pdata->shared_io) {
 734:	1a000015 	bne	790 <s3c_fimc_probe+0x150>
		/* request mem region */
		res = request_mem_region(res->start, res->end - res->start + 1, pdev->name);
 738:	e8900006 	ldm	r0, {r1, r2}
 73c:	e2822001 	add	r2, r2, #1
 740:	e5963000 	ldr	r3, [r6]
 744:	e59f02b4 	ldr	r0, [pc, #692]	; a00 <s3c_fimc_probe+0x3c0>
 748:	e0612002 	rsb	r2, r1, r2
 74c:	e58d7000 	str	r7, [sp]
 750:	ebfffffe 	bl	0 <__request_region>
		if (!res) {
 754:	e2503000 	subs	r3, r0, #0
			err("failed to request io memory region\n");
 758:	059f02a4 	ldreq	r0, [pc, #676]	; a04 <s3c_fimc_probe+0x3c4>
	}

	if (!pdata->shared_io) {
		/* request mem region */
		res = request_mem_region(res->start, res->end - res->start + 1, pdev->name);
		if (!res) {
 75c:	0a000015 	beq	7b8 <s3c_fimc_probe+0x178>
			err("failed to request io memory region\n");
			return NULL;
		}

		/* ioremap for register block */
		ctrl->regs = ioremap(res->start, res->end - res->start + 1);
 760:	e8930003 	ldm	r3, {r0, r1}
 764:	e2811001 	add	r1, r1, #1
 768:	e0601001 	rsb	r1, r0, r1
 76c:	e1a02007 	mov	r2, r7
 770:	ebfffffe 	bl	0 <__arm_ioremap>
 774:	e5840040 	str	r0, [r4, #64]	; 0x40
 778:	ea000007 	b	79c <s3c_fimc_probe+0x15c>
	} else {
		while (i >= 0 && ctrl->regs == NULL) {
			ctrl->regs = s3c_fimc.ctrl[i].regs;
 77c:	e5982490 	ldr	r2, [r8, #1168]	; 0x490
 780:	e2488f8a 	sub	r8, r8, #552	; 0x228
		}

		/* ioremap for register block */
		ctrl->regs = ioremap(res->start, res->end - res->start + 1);
	} else {
		while (i >= 0 && ctrl->regs == NULL) {
 784:	e1580003 	cmp	r8, r3
			ctrl->regs = s3c_fimc.ctrl[i].regs;
 788:	e5842040 	str	r2, [r4, #64]	; 0x40
		}

		/* ioremap for register block */
		ctrl->regs = ioremap(res->start, res->end - res->start + 1);
	} else {
		while (i >= 0 && ctrl->regs == NULL) {
 78c:	0a000002 	beq	79c <s3c_fimc_probe+0x15c>
 790:	e5942040 	ldr	r2, [r4, #64]	; 0x40
 794:	e3520000 	cmp	r2, #0
 798:	0afffff7 	beq	77c <s3c_fimc_probe+0x13c>
			ctrl->regs = s3c_fimc.ctrl[i].regs;
			i--;
		}
	}

	if (!ctrl->regs) {
 79c:	e59f3238 	ldr	r3, [pc, #568]	; 9dc <s3c_fimc_probe+0x39c>
 7a0:	e3a04f8a 	mov	r4, #552	; 0x228
 7a4:	e0243594 	mla	r4, r4, r5, r3
 7a8:	e5943040 	ldr	r3, [r4, #64]	; 0x40
 7ac:	e3530000 	cmp	r3, #0
 7b0:	1a000002 	bne	7c0 <s3c_fimc_probe+0x180>
		err("failed to remap io region\n");
 7b4:	e59f024c 	ldr	r0, [pc, #588]	; a08 <s3c_fimc_probe+0x3c8>
 7b8:	ebfffffe 	bl	0 <printk>
 7bc:	ea000015 	b	818 <s3c_fimc_probe+0x1d8>
		return NULL;
	}

	/* irq */
	ctrl->irq = platform_get_irq(pdev, 0);
 7c0:	e3a01000 	mov	r1, #0
 7c4:	e1a00006 	mov	r0, r6
 7c8:	ebfffffe 	bl	0 <platform_get_irq>

static inline int __must_check
request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
	    const char *name, void *dev)
{
	return request_threaded_irq(irq, handler, NULL, flags, name, dev);
 7cc:	e59d300c 	ldr	r3, [sp, #12]
 7d0:	e59f1234 	ldr	r1, [pc, #564]	; a0c <s3c_fimc_probe+0x3cc>
 7d4:	e3a02000 	mov	r2, #0
 7d8:	e5840048 	str	r0, [r4, #72]	; 0x48
 7dc:	e58d3000 	str	r3, [sp]
 7e0:	e3a03020 	mov	r3, #32
 7e4:	e58d4004 	str	r4, [sp, #4]
 7e8:	ebfffffe 	bl	0 <request_threaded_irq>
	if (request_irq(ctrl->irq, s3c_fimc_irq, IRQF_DISABLED, ctrl->name, ctrl))
 7ec:	e3500000 	cmp	r0, #0
 7f0:	0a000001 	beq	7fc <s3c_fimc_probe+0x1bc>
		err("request_irq failed\n");
 7f4:	e59f0214 	ldr	r0, [pc, #532]	; a10 <s3c_fimc_probe+0x3d0>
 7f8:	ebfffffe 	bl	0 <printk>

	s3c_fimc_reset(ctrl);
 7fc:	e1a00004 	mov	r0, r4
 800:	ebfffffe 	bl	0 <s3c_fimc_reset>
	s3c_fimc_set_active_camera(ctrl, 0);
 804:	e1a00004 	mov	r0, r4
 808:	e3a01000 	mov	r1, #0
 80c:	ebfffffe 	bl	574 <s3c_fimc_set_active_camera>
	struct s3c_fimc_control *ctrl;
	struct clk *srclk;
	int ret;
printk("=============fimc probe \n");//hnmsky
	ctrl = s3c_fimc_register_controller(pdev);
	if (!ctrl) {
 810:	e3540000 	cmp	r4, #0
 814:	1a000002 	bne	824 <s3c_fimc_probe+0x1e4>
		err("cannot register fimc controller\n");
 818:	e59f01f4 	ldr	r0, [pc, #500]	; a14 <s3c_fimc_probe+0x3d4>
 81c:	ebfffffe 	bl	0 <printk>
 820:	ea000068 	b	9c8 <s3c_fimc_probe+0x388>

struct s3c_platform_fimc *to_fimc_plat(struct device *dev)
{
	struct platform_device *pdev = to_platform_device(dev);

	return (struct s3c_platform_fimc *) pdev->dev.platform_data;
 824:	e596405c 	ldr	r4, [r6, #92]	; 0x5c
		err("cannot register fimc controller\n");
		goto err_fimc;
	}

	pdata = to_fimc_plat(&pdev->dev);
	if (pdata->cfg_gpio)
 828:	e5943030 	ldr	r3, [r4, #48]	; 0x30
 82c:	e3530000 	cmp	r3, #0
 830:	0a000001 	beq	83c <s3c_fimc_probe+0x1fc>
		pdata->cfg_gpio(pdev);
 834:	e1a00006 	mov	r0, r6
 838:	e12fff33 	blx	r3
printk("src name  %s   name  %s\n",pdata->srclk_name,pdata->clk_name);
 83c:	e2847010 	add	r7, r4, #16
 840:	e1a01004 	mov	r1, r4
 844:	e1a02007 	mov	r2, r7
 848:	e59f01c8 	ldr	r0, [pc, #456]	; a18 <s3c_fimc_probe+0x3d8>
 84c:	ebfffffe 	bl	0 <printk>
	/* fimc source clock */
	srclk = clk_get(&pdev->dev, pdata->srclk_name);
 850:	e1a0000b 	mov	r0, fp
 854:	e1a01004 	mov	r1, r4
 858:	ebfffffe 	bl	0 <clk_get>
	if (IS_ERR(srclk)) {
 85c:	e3700a01 	cmn	r0, #4096	; 0x1000
	pdata = to_fimc_plat(&pdev->dev);
	if (pdata->cfg_gpio)
		pdata->cfg_gpio(pdev);
printk("src name  %s   name  %s\n",pdata->srclk_name,pdata->clk_name);
	/* fimc source clock */
	srclk = clk_get(&pdev->dev, pdata->srclk_name);
 860:	e1a08000 	mov	r8, r0
	if (IS_ERR(srclk)) {
		err("failed to get source clock of fimc\n");
 864:	859f01b0 	ldrhi	r0, [pc, #432]	; a1c <s3c_fimc_probe+0x3dc>
	if (pdata->cfg_gpio)
		pdata->cfg_gpio(pdev);
printk("src name  %s   name  %s\n",pdata->srclk_name,pdata->clk_name);
	/* fimc source clock */
	srclk = clk_get(&pdev->dev, pdata->srclk_name);
	if (IS_ERR(srclk)) {
 868:	8a000009 	bhi	894 <s3c_fimc_probe+0x254>
		err("failed to get source clock of fimc\n");
		goto err_clk_io;
	}

	/* fimc clock */
	ctrl->clock = clk_get(&pdev->dev, pdata->clk_name);
 86c:	e1a01007 	mov	r1, r7
 870:	e1a0000b 	mov	r0, fp
 874:	ebfffffe 	bl	0 <clk_get>
 878:	e3a01f8a 	mov	r1, #552	; 0x228
 87c:	e59f2158 	ldr	r2, [pc, #344]	; 9dc <s3c_fimc_probe+0x39c>
 880:	e0222591 	mla	r2, r1, r5, r2
	if (IS_ERR(ctrl->clock)) {
 884:	e3700a01 	cmn	r0, #4096	; 0x1000
		err("failed to get source clock of fimc\n");
		goto err_clk_io;
	}

	/* fimc clock */
	ctrl->clock = clk_get(&pdev->dev, pdata->clk_name);
 888:	e582003c 	str	r0, [r2, #60]	; 0x3c
	if (IS_ERR(ctrl->clock)) {
 88c:	9a000002 	bls	89c <s3c_fimc_probe+0x25c>
		err("failed to get fimc clock source\n");
 890:	e59f0188 	ldr	r0, [pc, #392]	; a20 <s3c_fimc_probe+0x3e0>
 894:	ebfffffe 	bl	0 <printk>
		goto err_clk_io;
 898:	ea000048 	b	9c0 <s3c_fimc_probe+0x380>
	}

	/* set parent clock */
	//if (ctrl->clock->set_parent)
	//	ctrl->clock->set_parent(ctrl->clock, srclk);
	if (ctrl->clock->ops->set_parent)//hnmsky
 89c:	e5903024 	ldr	r3, [r0, #36]	; 0x24
 8a0:	e593300c 	ldr	r3, [r3, #12]
 8a4:	e3530000 	cmp	r3, #0
 8a8:	0a000001 	beq	8b4 <s3c_fimc_probe+0x274>
		ctrl->clock->ops->set_parent(ctrl->clock, srclk);
 8ac:	e1a01008 	mov	r1, r8
 8b0:	e12fff33 	blx	r3

	/* set clockrate for FIMC interface block */
	//if (ctrl->clock->set_rate)
	//	ctrl->clock->set_rate(ctrl->clock, pdata->clockrate);

	if (ctrl->clock->ops->set_rate)//hnmsky
 8b4:	e3a02f8a 	mov	r2, #552	; 0x228
 8b8:	e59f311c 	ldr	r3, [pc, #284]	; 9dc <s3c_fimc_probe+0x39c>
 8bc:	e0233592 	mla	r3, r2, r5, r3
 8c0:	e593003c 	ldr	r0, [r3, #60]	; 0x3c
 8c4:	e5903024 	ldr	r3, [r0, #36]	; 0x24
 8c8:	e5933000 	ldr	r3, [r3]
 8cc:	e3530000 	cmp	r3, #0
 8d0:	0a000001 	beq	8dc <s3c_fimc_probe+0x29c>
		ctrl->clock->ops->set_rate(ctrl->clock, pdata->clockrate);
 8d4:	e5941020 	ldr	r1, [r4, #32]
 8d8:	e12fff33 	blx	r3
	clk_enable(ctrl->clock);
 8dc:	e3a07f8a 	mov	r7, #552	; 0x228
 8e0:	e59f40f4 	ldr	r4, [pc, #244]	; 9dc <s3c_fimc_probe+0x39c>
 8e4:	e0070597 	mul	r7, r7, r5
 8e8:	e0843007 	add	r3, r4, r7
 8ec:	e593003c 	ldr	r0, [r3, #60]	; 0x3c
 8f0:	ebfffffe 	bl	0 <clk_enable>

	/* things to initialize once */
	if (ctrl->id == 0) {
 8f4:	e7947007 	ldr	r7, [r4, r7]
 8f8:	e3570000 	cmp	r7, #0
 8fc:	1a000014 	bne	954 <s3c_fimc_probe+0x314>
};

static int s3c_fimc_init_global(struct platform_device *pdev)
{
	/* camera clock */
	s3c_fimc.cam_clock = clk_get(&pdev->dev, "sclk_cam");
 900:	e1a0000b 	mov	r0, fp
 904:	e59f1118 	ldr	r1, [pc, #280]	; a24 <s3c_fimc_probe+0x3e4>
 908:	ebfffffe 	bl	0 <clk_get>
	if (IS_ERR(s3c_fimc.cam_clock)) {
 90c:	e3700a01 	cmn	r0, #4096	; 0x1000
};

static int s3c_fimc_init_global(struct platform_device *pdev)
{
	/* camera clock */
	s3c_fimc.cam_clock = clk_get(&pdev->dev, "sclk_cam");
 910:	e5840688 	str	r0, [r4, #1672]	; 0x688
	if (IS_ERR(s3c_fimc.cam_clock)) {
 914:	9a000002 	bls	924 <s3c_fimc_probe+0x2e4>
		err("failed to get camera clock source\n");
 918:	e59f0108 	ldr	r0, [pc, #264]	; a28 <s3c_fimc_probe+0x3e8>
 91c:	ebfffffe 	bl	0 <printk>
 920:	ea00001f 	b	9a4 <s3c_fimc_probe+0x364>
		return -EINVAL;
	}

	s3c_fimc.dma_start = s3c_get_media_memory(S3C_MDEV_FIMC);
 924:	e1a00007 	mov	r0, r7
 928:	ebfffffe 	bl	0 <s3c_get_media_memory>
 92c:	e584068c 	str	r0, [r4, #1676]	; 0x68c
	s3c_fimc.dma_total = s3c_get_media_memsize(S3C_MDEV_FIMC);
 930:	e1a00007 	mov	r0, r7
 934:	ebfffffe 	bl	0 <s3c_get_media_memsize>
	s3c_fimc.dma_current = s3c_fimc.dma_start;
 938:	e594368c 	ldr	r3, [r4, #1676]	; 0x68c
 93c:	e5843690 	str	r3, [r4, #1680]	; 0x690

	/* test pattern */
	s3c_fimc.camera[test_pattern.id] = &test_pattern;
 940:	e59f30e4 	ldr	r3, [pc, #228]	; a2c <s3c_fimc_probe+0x3ec>
 944:	e5b323e0 	ldr	r2, [r3, #992]!	; 0x3e0
		err("failed to get camera clock source\n");
		return -EINVAL;
	}

	s3c_fimc.dma_start = s3c_get_media_memory(S3C_MDEV_FIMC);
	s3c_fimc.dma_total = s3c_get_media_memsize(S3C_MDEV_FIMC);
 948:	e5840694 	str	r0, [r4, #1684]	; 0x694
	s3c_fimc.dma_current = s3c_fimc.dma_start;

	/* test pattern */
	s3c_fimc.camera[test_pattern.id] = &test_pattern;
 94c:	e0844102 	add	r4, r4, r2, lsl #2
 950:	e5843678 	str	r3, [r4, #1656]	; 0x678
		ret = s3c_fimc_init_global(pdev);
		if (ret)
			goto err_global;
	}

	ret = video_register_device(ctrl->vd, VFL_TYPE_GRABBER, ctrl->id);
 954:	e3a07f8a 	mov	r7, #552	; 0x228
 958:	e59f407c 	ldr	r4, [pc, #124]	; 9dc <s3c_fimc_probe+0x39c>
 95c:	e0070597 	mul	r7, r7, r5
 960:	e3a01000 	mov	r1, #0
 964:	e0843007 	add	r3, r4, r7
 968:	e7942007 	ldr	r2, [r4, r7]
 96c:	e593004c 	ldr	r0, [r3, #76]	; 0x4c
 970:	ebfffffe 	bl	0 <video_register_device>
	if (ret) {
 974:	e2508000 	subs	r8, r0, #0
 978:	0a000004 	beq	990 <s3c_fimc_probe+0x350>
		err("cannot register video driver\n");
 97c:	e59f00ac 	ldr	r0, [pc, #172]	; a30 <s3c_fimc_probe+0x3f0>
 980:	ebfffffe 	bl	0 <printk>
	info("controller %d registered successfully\n", ctrl->id);

	return 0;

err_video:
	clk_put(s3c_fimc.cam_clock);
 984:	e5940688 	ldr	r0, [r4, #1672]	; 0x688
 988:	ebfffffe 	bl	0 <clk_put>
 98c:	ea000004 	b	9a4 <s3c_fimc_probe+0x364>
	if (ret) {
		err("cannot register video driver\n");
		goto err_video;
	}

	info("controller %d registered successfully\n", ctrl->id);
 990:	e59f009c 	ldr	r0, [pc, #156]	; a34 <s3c_fimc_probe+0x3f4>
 994:	e7941007 	ldr	r1, [r4, r7]
 998:	ebfffffe 	bl	0 <printk>

	return 0;
 99c:	e1a00008 	mov	r0, r8
 9a0:	ea000009 	b	9cc <s3c_fimc_probe+0x38c>

err_video:
	clk_put(s3c_fimc.cam_clock);

err_global:
	clk_disable(ctrl->clock);
 9a4:	e3a02f8a 	mov	r2, #552	; 0x228
 9a8:	e59f302c 	ldr	r3, [pc, #44]	; 9dc <s3c_fimc_probe+0x39c>
 9ac:	e0253592 	mla	r5, r2, r5, r3
 9b0:	e595003c 	ldr	r0, [r5, #60]	; 0x3c
 9b4:	ebfffffe 	bl	0 <clk_disable>
	clk_put(ctrl->clock);
 9b8:	e595003c 	ldr	r0, [r5, #60]	; 0x3c
 9bc:	ebfffffe 	bl	0 <clk_put>

err_clk_io:
	s3c_fimc_unregister_controller(pdev);
 9c0:	e5960004 	ldr	r0, [r6, #4]
 9c4:	ebfffe5c 	bl	33c <s3c_fimc_unregister_controller.clone.0>

err_fimc:
	return -EINVAL;
 9c8:	e3e00015 	mvn	r0, #21
	
}
 9cc:	e28dd014 	add	sp, sp, #20
 9d0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
 9d4:	00000114 	.word	0x00000114
 9d8:	00000050 	.word	0x00000050
 9dc:	00000000 	.word	0x00000000
 9e0:	00000133 	.word	0x00000133
 9e4:	0000012e 	.word	0x0000012e
	...
 9f0:	00000698 	.word	0x00000698
 9f4:	0000013c 	.word	0x0000013c
 9f8:	00000148 	.word	0x00000148
 9fc:	fffff988 	.word	0xfffff988
 a00:	00000000 	.word	0x00000000
 a04:	00000175 	.word	0x00000175
 a08:	000001a6 	.word	0x000001a6
 a0c:	00000000 	.word	0x00000000
 a10:	000001ce 	.word	0x000001ce
 a14:	000001ef 	.word	0x000001ef
 a18:	0000021d 	.word	0x0000021d
 a1c:	00000236 	.word	0x00000236
 a20:	00000267 	.word	0x00000267
 a24:	00000295 	.word	0x00000295
 a28:	0000029e 	.word	0x0000029e
 a2c:	00000000 	.word	0x00000000
 a30:	000002ce 	.word	0x000002ce
 a34:	000002f9 	.word	0x000002f9

00000a38 <s3c_fimc_init_camera>:
	if (ctrl->in_cam && id < S3C_FIMC_TPID)
		s3c_fimc_select_camera(ctrl);
}

void s3c_fimc_init_camera(struct s3c_fimc_control *ctrl)
{
 a38:	e92d4070 	push	{r4, r5, r6, lr}
 a3c:	e1a06000 	mov	r6, r0
	struct s3c_fimc_camera *cam = ctrl->in_cam;
 a40:	e59040f8 	ldr	r4, [r0, #248]	; 0xf8

	if (cam && cam->id != S3C_FIMC_TPID && !cam->initialized) {
 a44:	e3540000 	cmp	r4, #0
 a48:	08bd8070 	popeq	{r4, r5, r6, pc}
 a4c:	e5943000 	ldr	r3, [r4]
 a50:	e3530003 	cmp	r3, #3
 a54:	08bd8070 	popeq	{r4, r5, r6, pc}
 a58:	e5945040 	ldr	r5, [r4, #64]	; 0x40
 a5c:	e3550000 	cmp	r5, #0
 a60:	18bd8070 	popne	{r4, r5, r6, pc}
		s3c_fimc_i2c_command(ctrl, I2C_CAM_INIT, 0);
 a64:	e1a01005 	mov	r1, r5
 a68:	e1a02005 	mov	r2, r5
 a6c:	ebfffffe 	bl	4a4 <s3c_fimc_i2c_command>
		s3c_fimc_change_resolution(ctrl, CAM_RES_DEFAULT);
 a70:	e1a00006 	mov	r0, r6
 a74:	e1a01005 	mov	r1, r5
 a78:	ebfffffe 	bl	0 <s3c_fimc_change_resolution>
		cam->initialized = 1;
 a7c:	e3a03001 	mov	r3, #1
 a80:	e5843040 	str	r3, [r4, #64]	; 0x40
 a84:	e8bd8070 	pop	{r4, r5, r6, pc}
